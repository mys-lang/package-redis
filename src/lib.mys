from io.buffered_reader import BufferedReader
from net.tcp.client import Client as TcpClient

class RedisError(Error):
    message: string

@trait
class Message:
    """A received Pub/Sub message.

    """

class SubscribeMessage(Message):
    """A subscribe reply message.

    """

    channel: string
    number_of_subscriptions: i64

class UnsubscribeMessage(Message):
    """An unsubscribe reply message.

    """

    channel: string
    number_of_subscriptions: i64

class PublishMessage(Message):
    """A published message.

    """

    channel: string
    payload: bytes

@trait
class Reply:
    """A reply.

    """

class SimpleStringReply(Reply):
    """A simple string.

    """

    value: string

class ErrorReply(Reply):
    """An error.

    """

    error: string
    message: string

class IntegerReply(Reply):
    """An integer.

    """

    value: i64

class BulkStringReply(Reply):
    """A bulk string.

    """

    value: bytes

class ArrayReply(Reply):
    """An array.

    """

    items: [Reply]

class Client:
    """A Redis client.

    """

    _client: TcpClient
    _buffered_reader: BufferedReader

    func __init__(self):
        self._client = TcpClient()
        self._buffered_reader = None

    func connect(self, host: string = "127.0.0.1", port: u32 = 6379):
        """Connect to given server.

        """

        self._client.connect(host, port)
        self._buffered_reader = BufferedReader(self._client)

    func disconnect(self):
        """Disconnect from the server.

        """

        self._client.disconnect()

    func auth(self, password: string):
        """Authenticate.

        """

        self._call_ok_reply([b"AUTH", password.to_utf8()])

    func set(self, key: string, value: bytes):
        """Set given value for given key.

        """

        self._call_ok_reply([b"SET", key.to_utf8(), value])

    func get(self, key: string) -> bytes:
        """Get the value for given key.

        """

        return self._call_string_reply([b"GET", key.to_utf8()])

    func getdel(self, key: string) -> bytes:
        """Get the value for given key and then delete it.

        """

        return self._call_string_reply([b"GETDEL", key.to_utf8()])

    func append(self, key: string, value: bytes) -> i64:
        """Append given value for given key.

        """

        return self._call_integer_reply([b"APPEND", key.to_utf8(), value])

    func incr(self, key: string) -> i64:
        """Increment the value for given key. Returns the value after the
        increment.

        """

        return self._call_integer_reply([b"INCR", key.to_utf8()])

    func decr(self, key: string) -> i64:
        """Decrement the value for given key. Returns the value after the
        decrement.

        """

        return self._call_integer_reply([b"DECR", key.to_utf8()])

    func strlen(self, key: string) -> i64:
        """Get the value length for given key.

        """

        return self._call_integer_reply([b"STRLEN", key.to_utf8()])

    func lpush(self, key: string, value: bytes) -> i64:
        """Prepend given value for given key.

        """

        return self._call_integer_reply([b"LPUSH", key.to_utf8(), value])

    func lpop(self, key: string) -> bytes:
        """Pop the first value for given key.

        """

        return self._call_string_reply([b"LPOP", key.to_utf8()])

    func rpush(self, key: string, value: bytes) -> i64:
        """Append given value for given key.

        """

        return self._call_integer_reply([b"RPUSH", key.to_utf8(), value])

    func rpop(self, key: string) -> bytes:
        """Pop the last value for given key.

        """

        return self._call_string_reply([b"RPOP", key.to_utf8()])

    func publish(self, channel: string, message: bytes) -> i64:
        """Publish given message on given channel. Returns the number of
        clients that received the message.

        """

        return self._call_integer_reply([b"PUBLISH", channel.to_utf8(), message])

    func subscribe(self, channel: string):
        """Subscribe to given channel. May be called from any fiber, even
        if another fiber is waiting for a message.

        """

        self._write_request([b"SUBSCRIBE", channel.to_utf8()])

    func unsubscribe(self, channel: string):
        """Unsubscribe from given channel. May be called from any fiber, even
        if another fiber is waiting for a message.

        """

        self._write_request([b"UNSUBSCRIBE", channel.to_utf8()])

    func psubscribe(self, pattern: string):
        """Subscribe to given pattern. May be called from any fiber, even
        if another fiber is waiting for a message.

        """

        self._write_request([b"PSUBSCRIBE", pattern.to_utf8()])

    func punsubscribe(self, pattern: string):
        """Unsubscribe from given pattern. May be called from any fiber, even
        if another fiber is waiting for a message.

        """

        self._write_request([b"PUNSUBSCRIBE", pattern.to_utf8()])

    func get_message(self) -> Message:
        """Get the next message. Blocks until a message is received.

        """

        length = self._read_reply_array_length()

        if length < 3:
            raise RedisError("Array too short.")

        match self._read_reply_string():
            case b"message":
                channel = string(self._read_reply_string())
                payload = self._read_reply_string()

                return PublishMessage(channel, payload)
            case b"pmessage":
                self._read_reply_string()
                channel = string(self._read_reply_string())
                payload = self._read_reply_string()

                return PublishMessage(channel, payload)
            case b"subscribe":
                channel = string(self._read_reply_string())
                count = self._read_reply_integer()

                return SubscribeMessage(channel, count)
            case b"unsubscribe":
                channel = string(self._read_reply_string())
                count = self._read_reply_integer()

                return UnsubscribeMessage(channel, count)
            case b"psubscribe":
                channel = string(self._read_reply_string())
                count = self._read_reply_integer()

                return SubscribeMessage(channel, count)
            case b"punsubscribe":
                channel = string(self._read_reply_string())
                count = self._read_reply_integer()

                return UnsubscribeMessage(channel, count)
            case _ as kind:
                raise RedisError(f"Invalid message kind '{kind}'.")

    func call(self, request: [bytes]) -> Reply:
        """Send given request and wait for a reply.

        """

        self._write_request(request)

        return self._read_reply()

    func _read_reply(self) -> Reply:
        kind = self._buffered_reader.read(1)
        data = self._read_line()

        match kind:
            case b"-":
                error, _, message = string(data).partition(" ")

                return ErrorReply(error, message)
            case b"+":
                return SimpleStringReply(string(data))
            case b":":
                return IntegerReply(i64(string(data)))
            case b"$":
                length = i64(string(data))

                if length == -1:
                    return BulkStringReply(None)
                else:
                    return BulkStringReply(self._read_line())
            case b"*":
                length = i64(string(data))

                if length == -1:
                    return ArrayReply(None)
                else:
                    return ArrayReply([self._read_reply() for _ in range(length)])
            case _:
                raise RedisError(f"Invalid reply kind '{kind}'.")

    func _call_integer_reply(self, command: [bytes]) -> i64:
        self._write_request(command)

        return self._read_reply_integer()

    func _call_string_reply(self, command: [bytes]) -> bytes:
        self._write_request(command)

        return self._read_reply_string()

    func _call_ok_reply(self, command: [bytes]):
        self._write_request(command)
        self._read_reply_ok()

    func _read_reply_ok(self):
        kind = self._buffered_reader.read(1)

        if kind != b"+":
            raise RedisError("Not a response.")

        if self._read_line() != b"OK":
            raise RedisError("Not OK.")

    func _read_reply_string(self) -> bytes:
        kind = self._buffered_reader.read(1)

        if kind != b"$":
            raise RedisError("Not a string.")

        length = i64(string(self._read_line()))

        if length == -1:
            return None

        value = self._buffered_reader.read(u64(length))
        self._read_cr_lf()

        return value

    func _read_reply_integer(self) -> i64:
        kind = self._buffered_reader.read(1)

        if kind != b":":
            raise RedisError("Not an integer.")

        return i64(string(self._read_line()))

    func _read_reply_array_length(self) -> u64:
        if self._buffered_reader.read(1) != b"*":
            raise RedisError("Not an array.")

        return u64(string(self._read_line()))

    func _read_reply_string_payload(self, length: u64) -> bytes:
        value = self._buffered_reader.read(length)
        self._read_cr_lf()

        return value

    func _read_cr_lf(self):
        self._buffered_reader.read(2)

    func _write_request(self, command: [bytes]):
        request = f"*{len(command)}\r\n".to_utf8()

        for item in command:
            request += f"${len(item)}\r\n".to_utf8()
            request += item
            request += b"\r\n"

        self._client.write(request)

    func _read_line(self) -> bytes:
        return self._buffered_reader.read_until(b"\r\n", keep_pattern=False)
